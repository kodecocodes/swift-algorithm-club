<!DOCTYPE html>
<head>
  <title>QuadTree</title>
  <link rel="stylesheet" type="text/css" href="../github-light.css">
</head>
<body>
  <div id="container"><h1>QuadTree</h1>
<p>A quadtree is a <a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Tree">tree</a> in which each internal (not leaf) node has four children.</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/timaktimak/swift-algorithm-club/blob/master/QuadTree/Images/quadtree.png"><img src="https://github.com/timaktimak/swift-algorithm-club/blob/master/QuadTree/Images/quadtree.png" width="500" style="max-width:100%;"></a></p>
<h3>Problem</h3>
<p>Consider the following problem: your need to store a number of points (each point is a pair of <code>X</code> and <code>Y</code> coordinates) and then you need to answer which points lie in a certain rectangular region. A naive solution would be to store the points inside an array and then iterate over the points and check each one individually. This solution runs in O(n) though.</p>
<h3>A Better Approach</h3>
<p>Quadtrees are most commonly used to partition a two-dimensional space by recursively subdividing it into four regions(quadrants). Let's see how we can use a Quadtree to store the points.</p>
<p>Each node in the tree represents a rectangular region and stores a limited number(<code>maxPointCapacity</code>) of points that all lie in its region.</p>
<div class="highlight highlight-source-swift"><pre><span class="pl-k">class</span> <span class="pl-en">QuadTreeNode</span> {

  <span class="pl-k">enum</span> <span class="pl-en">NodeType</span> {
    <span class="pl-k">case</span> <span class="pl-c1">leaf</span>
    <span class="pl-k">case</span> <span class="pl-c1">`internal`</span>(<span class="pl-en"><span class="pl-smi">children</span></span>: <span class="pl-c1">Children</span>)
  }

  <span class="pl-k">struct</span> <span class="pl-en">Children</span> {
    <span class="pl-k">let</span> leftTop<span class="pl-k">:</span> QuadTreeNode
    <span class="pl-k">let</span> leftBottom<span class="pl-k">:</span> QuadTreeNode
    <span class="pl-k">let</span> rightTop<span class="pl-k">:</span> QuadTreeNode
    <span class="pl-k">let</span> rightBottom<span class="pl-k">:</span> QuadTreeNode

    <span class="pl-k">...</span>
  }

  <span class="pl-k">var</span> points<span class="pl-k">:</span> [Point] <span class="pl-k">=</span> []
  <span class="pl-k">let</span> rect<span class="pl-k">:</span> Rect
  <span class="pl-k">var</span> type<span class="pl-k">:</span> NodeType <span class="pl-k">=</span> .<span class="pl-smi">leaf</span>

  <span class="pl-k">static</span> <span class="pl-k">let</span> maxPointCapacity <span class="pl-k">=</span> <span class="pl-c1">3</span>

  <span class="pl-k">init</span>(<span class="pl-smi"><span class="pl-en">rect</span></span>: Rect) {
    <span class="pl-c1">self</span>.<span class="pl-smi">rect</span> <span class="pl-k">=</span> rect
  }

  <span class="pl-k">...</span>
}
</pre></div>
<p>Once the limit in a leaf node is reached, four child nodes are added to the node and they represent <code>topLeft</code>, <code>topRight</code>, <code>bottomLeft</code>, <code>bottomRight</code> quadrants of the node's rect; each of the consequent points in the rect will be passed to one of the children. Thus, new points are always added to leaf nodes.</p>
<div class="highlight highlight-source-swift"><pre><span class="pl-k">extension</span> <span class="pl-en">QuadTreeNode</span> {

  <span class="pl-k">@discardableResult</span>
  <span class="pl-k">func</span> <span class="pl-en">add</span>(<span class="pl-smi"><span class="pl-en">point</span></span>: Point) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> {

    <span class="pl-k">if</span> <span class="pl-k">!</span>rect.<span class="pl-c1">contains</span>(<span class="pl-c1">point</span>: point) {
      <span class="pl-k">return</span> <span class="pl-c1">false</span>
    }

    <span class="pl-k">switch</span> type {
    <span class="pl-k">case</span> .<span class="pl-c1">internal</span>(<span class="pl-k">let</span> children)<span class="pl-k">:</span>
      <span class="pl-c"><span class="pl-c">//</span> pass the point to one of the children</span>
<span class="pl-c"></span>      <span class="pl-k">for</span> child <span class="pl-k">in</span> children {
        <span class="pl-k">if</span> child.<span class="pl-c1">add</span>(<span class="pl-c1">point</span>: point) {
          <span class="pl-k">return</span> <span class="pl-c1">true</span>
        }
      }
      <span class="pl-k">return</span> <span class="pl-c1">false</span> <span class="pl-c"><span class="pl-c">//</span> should never happen</span>
<span class="pl-c"></span>    <span class="pl-k">case</span> .<span class="pl-smi">leaf</span><span class="pl-k">:</span>
      points.<span class="pl-c1">append</span>(point)
      <span class="pl-c"><span class="pl-c">//</span> if the max capacity was reached, become an internal node</span>
<span class="pl-c"></span>      <span class="pl-k">if</span> points.<span class="pl-c1">count</span> <span class="pl-k">==</span> QuadTreeNode.<span class="pl-smi">maxPointCapacity</span> {
        <span class="pl-c1">subdivide</span>()
      }
    }
    <span class="pl-k">return</span> <span class="pl-c1">true</span>
  }

  <span class="pl-k">private</span> <span class="pl-k">func</span> <span class="pl-en">subdivide</span>() {
    <span class="pl-k">switch</span> type {
    <span class="pl-k">case</span> .<span class="pl-smi">leaf</span><span class="pl-k">:</span>
      type <span class="pl-k">=</span> .<span class="pl-c1">internal</span>(<span class="pl-c1">children</span>: <span class="pl-c1">Children</span>(<span class="pl-c1">parentNode</span>: <span class="pl-c1">self</span>))
    <span class="pl-k">case</span> .<span class="pl-smi">internal</span><span class="pl-k">:</span>
      <span class="pl-c1">preconditionFailure</span>(<span class="pl-s"><span class="pl-pds">"</span>Calling subdivide on an internal node<span class="pl-pds">"</span></span>)
    }
  }
}

<span class="pl-k">extension</span> <span class="pl-en"><span class="pl-c1">Children</span></span> {

  <span class="pl-k">init</span>(<span class="pl-smi"><span class="pl-en">parentNode</span></span>: QuadTreeNode) {
    leftTop <span class="pl-k">=</span> <span class="pl-c1">QuadTreeNode</span>(<span class="pl-c1">rect</span>: parentNode.<span class="pl-smi">rect</span>.<span class="pl-smi">leftTopRect</span>)
    leftBottom <span class="pl-k">=</span> <span class="pl-c1">QuadTreeNode</span>(<span class="pl-c1">rect</span>: parentNode.<span class="pl-smi">rect</span>.<span class="pl-smi">leftBottomRect</span>)
    rightTop <span class="pl-k">=</span> <span class="pl-c1">QuadTreeNode</span>(<span class="pl-c1">rect</span>: parentNode.<span class="pl-smi">rect</span>.<span class="pl-smi">rightTopRect</span>)
    rightBottom <span class="pl-k">=</span> <span class="pl-c1">QuadTreeNode</span>(<span class="pl-c1">rect</span>: parentNode.<span class="pl-smi">rect</span>.<span class="pl-smi">rightBottomRect</span>)
  }
}
</pre></div>
<p>To find the points that lie in a given region we can now traverse the tree from top to bottom and collect the suitable points from nodes.</p>
<div class="highlight highlight-source-swift"><pre><span class="pl-k">class</span> <span class="pl-en">QuadTree</span> {

  <span class="pl-k">...</span>

  <span class="pl-k">let</span> root<span class="pl-k">:</span> QuadTreeNode

   <span class="pl-k">public</span> <span class="pl-k">func</span> <span class="pl-en">points</span>(<span class="pl-en">inRect</span> <span class="pl-smi">rect</span>: Rect) <span class="pl-k">-&gt;</span> [Point] {
    <span class="pl-k">return</span> root.<span class="pl-c1">points</span>(<span class="pl-c1">inRect</span>: rect)
  }
}

<span class="pl-k">extension</span> <span class="pl-en">QuadTreeNode</span> {
  <span class="pl-k">func</span> <span class="pl-en">points</span>(<span class="pl-en">inRect</span> <span class="pl-smi">rect</span>: Rect) <span class="pl-k">-&gt;</span> [Point] {

    <span class="pl-c"><span class="pl-c">//</span> if the node's rect and the given rect don't intersect, return an empty array,</span>
<span class="pl-c"></span>    <span class="pl-c"><span class="pl-c">//</span> because there can't be any points that lie the node's (or its children's) rect and</span>
<span class="pl-c"></span>    <span class="pl-c"><span class="pl-c">//</span> in the given rect</span>
<span class="pl-c"></span>    <span class="pl-k">if</span> <span class="pl-k">!</span><span class="pl-c1">self</span>.<span class="pl-smi">rect</span>.<span class="pl-c1">intersects</span>(<span class="pl-c1">rect</span>: rect) {
      <span class="pl-k">return</span> []
    }

    <span class="pl-k">var</span> result<span class="pl-k">:</span> [Point] <span class="pl-k">=</span> []

    <span class="pl-c"><span class="pl-c">//</span> collect the node's points that lie in the rect</span>
<span class="pl-c"></span>    <span class="pl-k">for</span> point <span class="pl-k">in</span> points {
      <span class="pl-k">if</span> rect.<span class="pl-c1">contains</span>(<span class="pl-c1">point</span>: point) {
        result.<span class="pl-c1">append</span>(point)
      }
    }

    <span class="pl-k">switch</span> type {
    <span class="pl-k">case</span> .<span class="pl-smi">leaf</span><span class="pl-k">:</span>
      <span class="pl-k">break</span>
    <span class="pl-k">case</span> .<span class="pl-c1">internal</span>(<span class="pl-c1">children</span>: <span class="pl-k">let</span> children)<span class="pl-k">:</span>
      <span class="pl-c"><span class="pl-c">//</span> recursively add children's points that lie in the rect</span>
<span class="pl-c"></span>      <span class="pl-k">for</span> childNode <span class="pl-k">in</span> children {
        result.<span class="pl-c1">append</span>(<span class="pl-c1">contentsOf</span>: childNode.<span class="pl-c1">points</span>(<span class="pl-c1">inRect</span>: rect))
      }
    }

    <span class="pl-k">return</span> result
  }
}
</pre></div>
<p>Both adding a point and searching can still take up to O(n) in the worst case, since the tree isn't balanced in any way. However, on average it runs significantly faster (something comparable to O(log n)).</p>
<h3>See also</h3>
<p>Displaying a large amount of objects in a MapView - a great use case for a Quadtree (<a href="https://robots.thoughtbot.com/how-to-handle-large-amounts-of-data-on-maps" rel="nofollow">Thoughtbot Article</a>)</p>
<p>More info on <a href="https://en.wikipedia.org/wiki/Quadtree" rel="nofollow">Wikipedia</a></p>
<p><em>Written for Swift Algorithm Club by Timur Galimov</em></p></div>
</body>
</html>

# Z ç®—æ³•å­—ç¬¦ä¸²æœç´¢

ç›®æ ‡ï¼šç”¨ Swift å†™ä¸€ä¸ªç®€å•çš„çº¿æ€§æ—¶é—´çš„å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•æ¥è¿”å›ç»™å®šæ¨¡å¼åœ¨å­—ç¬¦ä¸²ä¸­çš„å‡ºç°çš„æ‰€æœ‰ç´¢å¼•ã€‚
 
æ¢å¥è¯è¯´ï¼Œæƒ³è¦å®ç° `String` çš„ä¸€ä¸ªæ‰©å±• `indexesOf(pattern: String)` è¿”å›æ•´æ•°æ•°ç»„ `[Int]`ï¼Œè¡¨ç¤ºçš„æ˜¯æœç´¢æ¨¡å¼åœ¨å­—ç¬¦ä¸²ä¸­å‡ºç°çš„ç´¢å¼•ï¼Œæˆ–è€…å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•åŒ¹é…çš„è¯è¿”å› `nil`ã€‚
 
ä¾‹å¦‚ï¼š

```swift
let str = "Hello, playground!"
str.indexesOf(pattern: "ground")   // Output: [11]

let traffic = "ğŸš—ğŸš™ğŸšŒğŸš•ğŸš‘ğŸšğŸš—ğŸš’ğŸššğŸšğŸš›ğŸšğŸğŸšœğŸš—ğŸğŸš’ğŸš²ğŸš•ğŸš“ğŸšŒğŸš‘"
traffic.indexesOf(pattern: "ğŸš‘") // Output: [4, 21]
```

è®¸å¤šå­—ç¬¦ä¸²æœç´¢ç®—æ³•éƒ½ä¼šä½¿ç”¨ä¸€ä¸ªé¢„å¤„ç†å‡½æ•°æ¥å¾—åˆ°ä¸€ä¸ªåœ¨åç»­æ­¥éª¤é‡Œä¼šä½¿ç”¨åˆ°çš„è¡¨æ ¼ã€‚è¿™ä¸ªè¡¨æ ¼åœ¨æ¨¡å¼æœç´¢çš„æ—¶å€™èƒ½å¤ŸèŠ‚çœæ—¶é—´ï¼Œå› ä¸ºå®ƒå¯ä»¥é¿å…ä¸å¿…è¦çš„å­—ç¬¦æ¯”è¾ƒã€‚[Z ç®—æ³•](README-CN.markdown) æ˜¯å…¶ä¸­ä¸€ä¸ªå‡½æ•°ã€‚å®ƒæ˜¯ä½œä¸ºæ¨¡å¼é¢„å¤„ç†å‡½æ•°ï¼ˆè¿™å°±æ˜¯å®ƒåœ¨ [Knuth-Morris-Pratt ç®—æ³•](../Knuth-Morris-Pratt/README-CN.markdown) å’Œå…¶ä»–ç®—æ³•é‡Œçš„è§’è‰²ï¼‰è€Œè¯ç”Ÿçš„ï¼Œä½†æ˜¯ï¼Œå°±åƒæˆ‘ä»¬è¿™é‡Œå±•ç¤ºçš„ä¸€æ ·ï¼Œå®ƒä¹Ÿå¯ä»¥ç”¨æ¥åšç®€å•çš„å­—ç¬¦ä¸²æœç´¢ç®—æ³•ã€‚

### Z ç®—æ³•ä½œä¸ºæ¨¡å¼é¢„å¤„ç†

å°±åƒæˆ‘ä»¬å‰é¢è¯´çš„ï¼ŒZ ç®—æ³•æœ€å¼€å§‹æ˜¯ä¸ºäº†è®¡ç®—è·³è¿‡æ¯”è¾ƒè¡¨è€Œç”¨æ¥å¤„ç†æ¨¡å¼çš„ç®—æ³•ã€‚
Z ç®—æ³•å¯¹æ¨¡å¼ `P` çš„è®¡ç®—ä¼šç”Ÿæˆä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼ˆå†™åš `Z`ï¼‰ï¼Œæ•°ç»„é‡Œçš„æ¯ä¸ªå…ƒç´ ï¼Œ`Z[i]`ï¼Œè¡¨ç¤ºçš„æ˜¯ä» `i` å¼€å§‹çš„å¹¶ä¸”ä¸ `P` çš„å‰ç¼€åŒ¹é…çš„æœ€é•¿å­ä¸²çš„é•¿åº¦ã€‚ç®€å•æ¥è¯´æˆ–ï¼Œ `Z[i]`  è®°å½•çš„æ˜¯ä¸å‰ç¼€ `P` åŒ¹é…çš„æœ€é•¿çš„ `P[i...|P|]` çš„å‰ç¼€ã€‚ä¸¾ä¸ªä¾‹å­æ¥æ‰€ï¼Œå‡è®¾ `P = "ffgtrhghhffgtggfredg"`ã€‚é‚£ä¹ˆå°±æœ‰ `Z[5] = 0 (f...h...)`, `Z[9] = 4 (ffgtr...ffgtg...)` å’Œ `Z[15] = 1 (ff...fr...)`ã€‚
ä½†æ˜¯æˆ‘ä»¬æ€ä¹ˆè®¡ç®— `Z` å‘¢ï¼Ÿåœ¨æè¿°ç®—æ³•ä¹‹å‰æˆ‘ä»¬å…ˆè¦ä»‹ç»ä¸€ä¸‹ Z ç›’å­çš„æ¦‚å¿µã€‚Z ç›’å­æ˜¯åœ¨è®¡ç®—æ—¶ç”¨åˆ°çš„ä¸€å¯¹ `(left, right)`ï¼Œç”¨æ¥è®°å½•å­ä¸²ä¸­ä¸ `P` çš„å‰ç¼€åŒ¹é…çš„æœ€é•¿å­ä¸²çš„é•¿åº¦ã€‚`left` å’Œ `right` è¿™ä¸¤ä¸ªç´¢å¼•åˆ†åˆ«è¡¨ç¤ºè¿™ä¸ªå­ä¸²çš„å·¦è¾¹å’Œå³è¾¹çš„ç´¢å¼•ã€‚
Z ç®—æ³•çš„å®šä¹‰æ˜¯ç”±å½’çº³å¾—å‡ºçš„ï¼Œå¯¹äºæ¨¡å¼é‡Œçš„æ¯ä¸€ä¸ªä½ç½® `k` å®ƒéƒ½ä¼šè®¡ç®—å¾—å‡ºæ•°ç»„ä¸­çš„å…ƒç´ ï¼Œä» `k = 1` å¼€å§‹ã€‚ (`Z[k + 1]`, `Z[k + 2]`, ...) çš„å€¼æ˜¯åœ¨ `Z[k]` ä¹‹åè®¡ç®—çš„ã€‚è¿™ä¸ªç®—æ³•èƒŒåçš„æ€æƒ³æ˜¯å‰é¢å·²ç»è®¡ç®—çš„å€¼å¯ä»¥åŠ é€Ÿè®¡ç®— `Z[k + 1]` çš„å€¼ï¼Œå¯ä»¥é¿å…ä¸€äº›å·²ç»åšäº†çš„å­—ç¬¦æ¯”è¾ƒã€‚çœ‹çœ‹è¿™ä¸ªä¾‹å­ï¼Œå‡è®¾æˆ‘ä»¬å·²ç»è¿­ä»£åˆ° `k = 100` äº†ï¼Œæˆ‘ä»¬æ­£åœ¨åˆ†ææ¨¡å¼çš„ç¬¬ `100` çš„ä½ç½®ã€‚æ‰€æœ‰ `Z[1]` å’Œ `Z[99]` ä¹‹é—´çš„å€¼å·²ç»è®¡ç®—æ­£ç¡®äº†å¹¶ä¸” `left = 70` å’Œ `right = 120`ã€‚è¿™å°±æ˜¯è¯´æœ‰ä¸€ä¸ªé•¿åº¦ä¸º `51` çš„å­ä¸²ï¼Œä»ä½ç½® `70` å¼€å§‹ï¼Œåœ¨ä½ç½® `120` ç»“æŸä¸æˆ‘ä»¬è¦å¤„ç†çš„æ¨¡å¼/å­—ç¬¦ä¸²çš„å‰ç¼€åŒ¹é…ã€‚åŸºäºè¿™ä¸ªæˆ‘ä»¬å¯ä»¥çŸ¥é“ä» `100` å¼€å§‹çš„é•¿åº¦ä¸º `21` çš„å­ä¸²ä¸ä» `30` å¼€å§‹çš„é•¿åº¦ä¸º `21` çš„æ¨¡å¼çš„å­ä¸²æ˜¯åŒ¹é…çš„ï¼ˆå› ä¸ºæˆ‘ä»¬æ˜¯åœ¨ä¸æ¨¡å¼çš„å‰ç¼€åŒ¹é…çš„å­ä¸²é‡Œé¢ï¼‰ã€‚æ‰€ä»¥å¯ä»¥åœ¨ä¸éœ€è¦é¢å¤–çš„å­—ç¬¦å¯¹æ¯”çš„æƒ…å†µä¸‹ç”¨ `Z[30]` æ¥è®¡ç®— `Z[100]` ã€‚
è¿™æ˜¯è¿™ä¸ªç®—æ³•èƒŒåçš„æ€æƒ³çš„ç®€å•æè¿°ã€‚å½“å·²è®¡ç®—å¥½çš„å€¼ä¸èƒ½ç›´æ¥ç”¨æ—¶å°±å°±éœ€è¦åšä¸€äº›æ¯”è¾ƒäº†ã€‚

ä¸‹é¢æ˜¯è®¡ç®— Z æ•°ç»„æ–¹æ³•çš„ä»£ç ï¼š

```swift
func ZetaAlgorithm(ptrn: String) -> [Int]? {

    let pattern = Array(ptrn.characters)
    let patternLength: Int = pattern.count

    guard patternLength > 0 else {
        return nil
    }

    var zeta: [Int] = [Int](repeating: 0, count: patternLength)

    var left: Int = 0
    var right: Int = 0
    var k_1: Int = 0
    var betaLength: Int = 0
    var textIndex: Int = 0
    var patternIndex: Int = 0

    for k in 1 ..< patternLength {
        if k > right {  // Outside a Z-box: compare the characters until mismatch
            patternIndex = 0

            while k + patternIndex < patternLength  &&
                pattern[k + patternIndex] == pattern[patternIndex] {
                patternIndex = patternIndex + 1
            }

            zeta[k] = patternIndex

            if zeta[k] > 0 {
                left = k
                right = k + zeta[k] - 1
            }
        } else {  // Inside a Z-box
            k_1 = k - left + 1
            betaLength = right - k + 1

            if zeta[k_1 - 1] < betaLength { // Entirely inside a Z-box: we can use the values computed before
                zeta[k] = zeta[k_1 - 1]
            } else if zeta[k_1 - 1] >= betaLength { // Not entirely inside a Z-box: we must proceed with comparisons too
                textIndex = betaLength
                patternIndex = right + 1

                while patternIndex < patternLength && pattern[textIndex] == pattern[patternIndex] {
                    textIndex = textIndex + 1
                    patternIndex = patternIndex + 1
                }

                zeta[k] = patternIndex - k
                left = k
                right = patternIndex - 1
            }
        }
    }
    return zeta
}
```

æˆ‘ä»¬ä¸¾ä¸ªä¾‹å­æ¥ç”¨ä¸Šé¢çš„ä»£ç æ¥æ¨ç†ä¸€ä¸‹ã€‚å‡è®¾å­—ç¬¦ä¸²æ˜¯ `P = â€œabababbb"`ã€‚ç®—æ³•ä» `k = 1`ï¼Œ`left = right = 0` å¼€å§‹ï¼Œæ‰€ä»¥ Z ç›’å­è¿˜æ²¡æœ‰æ¿€æ´»ï¼Œå› ä¸º `k > right`ï¼Œå°±ä»æ¯”è¾ƒ `P[1]` and `P[0]` å¼€å§‹ã€‚
  
    
       01234567
    k:  x
       abababbb
       x
    Z: 00000000
    left:  0
    right: 0

ä¸€å¼€å§‹æˆ‘ä»¬å¾—åˆ°çš„æ˜¯ä¸€ä¸ªä¸åŒ¹é…çš„æ¯”è¾ƒï¼Œå› ä¸ºä» `P[1]` å¼€å§‹çš„å­ä¸²ä¸ `P` çš„å‰ç¼€ä¸åŒ¹é…ã€‚æ‰€ä»¥ï¼Œ`Z[1] = 0`ï¼Œå¹¶ä¸” `left` å’Œ `right` ä¸å˜ã€‚å¼€å§‹å¦ä¸€ä¸ª `k = 2` çš„è¿­ä»£ï¼Œ2 > 0 ï¼Œæ‰€ä»¥ç»§ç»­æ¯”è¾ƒ `P[2]` å’Œ `P[0]` å­—ç¬¦ã€‚è¿™æ¬¡ï¼Œå­—ç¬¦åŒ¹é…äº†ï¼Œç„¶åæˆ‘ä»¬å°±ç»§ç»­å¯¹æ¯”ç›´åˆ°å‡ºç°ä¸åŒ¹é…ã€‚åœ¨ä½ç½® `6` çš„æ—¶å€™å‡ºç°äº†ã€‚åŒ¹é…çš„å­—ç¬¦æ•°æ˜¯ `4`ï¼Œæ‰€ä»¥ `Z[2] = 4`ï¼Œ`left = k = 2` å’Œ `right = k + Z[k] - 1 = 5`ã€‚æˆ‘ä»¬æœ‰äº†ç¬¬ä¸€ä¸ª Z ç›’å­ï¼Œå®ƒçš„å­ä¸²æ˜¯ `"abab"`ï¼ˆæ³¨æ„ï¼Œå®ƒæ˜¯ä¸ `P` çš„å‰ç¼€åŒ¹é…çš„ï¼‰ï¼Œå®ƒæ˜¯ä» `left = 2` å¼€å§‹çš„ã€‚

       01234567
    k:   x
       abababbb
       x
    Z: 00400000
    left:  2
    right: 5

ç„¶åå¤„ç† `k = 3`ã€‚`3 <= 5`ï¼Œæˆ‘ä»¬åœ¨ä¹‹å‰æ‰¾åˆ°çš„ Z ç›’å­çš„å†…éƒ¨å¹¶ä¸”åœ¨ P çš„å‰ç¼€é‡Œã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŸ¥æ‰¾ä¸€ä¸ªåœ¨ä¹‹å‰è®¡ç®—çš„å€¼é‡Œçš„ä½ç½®ã€‚`k_1 = k - left = 1`ï¼Œè¿™å°±æ˜¯ä¸ `P[k]` ç›¸ç­‰çš„å­—ç¬¦çš„ç´¢å¼•ã€‚ç„¶åæ£€æŸ¥ `Z[1] = 0` å’Œ `0 < (right - k + 1 = 3)`ï¼Œå‘ç°æˆ‘ä»¬æ­£å¥½è¿˜åœ¨ Z ç›’å­é‡Œã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¹‹å‰è®¡ç®—å¥½çš„å€¼ï¼Œæ‰€ä»¥ `Z[3] = Z[1] = 0`, `left` å’Œ `right` ä¾ç„¶ä¿æŒä¸å˜ã€‚
åœ¨ `k = 4` çš„è¿­ä»£çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¼€å§‹å°±æ‰§è¡Œäº†å¤–å±‚ `if` çš„ `else` åˆ†æ”¯ã€‚åœ¨é‡Œé¢çš„ `if` é‡Œæœ‰ `k_1 = 2` å’Œ `(Z[2] = 4) >= 5 - 4 + 1`ã€‚æ‰€ä»¥å­ä¸² `P[k...r]` ä¸ `P` çš„å‰ç¼€ `right - k + 1 = 2` çš„å­—ç¬¦åŒ¹é…ï¼Œä½†æ˜¯å®ƒä¸æ˜¯åé¢çš„å­—ç¬¦ï¼Œæˆ‘ä»¬è¿˜éœ€è¦æ¯”è¾ƒä» `r + 1 = 6` å¼€å§‹çš„å’Œä» `right - k + 1 = 2` å¼€å§‹çš„å­—ç¬¦ã€‚`P[6] != P[2]`ï¼Œæ‰€ä»¥ `Z[k] = 6 - 4 = 2`, `left = 4` å’Œ `right = 5`ã€‚

       01234567
    k:     x
       abababbb
       x
    Z: 00402000
    left:  4
    right: 5

`k = 5` çš„æ—¶å€™ï¼Œ`k <= right` å¹¶ä¸” `(Z[k_1] = 0) < (right - k + 1 = 1)`ï¼Œæ‰€ä»¥ `z[k] = 0`ã€‚åœ¨è¿­ä»£ `6` å’Œ `7` çš„æ—¶å€™ï¼Œæˆ‘ä»¬æ‰§è¡Œäº†å¤–å±‚ if çš„ç¬¬ä¸€ä¸ªåˆ†æ”¯ä½†æ˜¯æ²¡æœ‰åŒ¹é…ï¼Œæ‰€ä»¥ç®—æ³•å°±ç»“æŸäº†ï¼Œè¿”å› `Z = [0, 0, 4, 0, 2, 0, 0, 0]`ã€‚

Z ç®—æ³•æ˜¯çº¿æ€§æ—¶é—´çš„ã€‚æ›´ç¡®åˆ‡çš„è¯´ï¼Œå¯¹äºå¤§å°ä¸º `n` çš„å­—ç¬¦ä¸² `P`ï¼ŒZ ç®—æ³•çš„æ—¶é—´æ˜¯ `O(n)`ã€‚

ä½œä¸ºå­—ç¬¦ä¸²é¢„å¤„ç†çš„ Z ç®—æ³•çš„å®ç°æ˜¯ [ZAlgorithm.swift](./ZAlgorithm.swift) æ–‡ä»¶é‡Œã€‚

### Z ç®—æ³• ç”¨ä½œå­—ç¬¦ä¸²æœç´¢ç®—æ³•

ä¸Šé¢è®¨è®ºçš„ Z ç®—æ³•å°±æ˜¯æœ€ç®€å•çš„çº¿æ€§æ—¶é—´çš„å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•äº†ã€‚ä¸ºäº†è·å¾—è¿™ä¸ªï¼Œæˆ‘ä»¬éœ€è¦ç®€å•çš„å°†æ¨¡å¼ `P` å’Œæ–‡æœ¬ `T` åˆå¹¶æˆä¸€ä¸ªå­—ç¬¦ä¸² `S = P$T`ï¼Œå…¶ä¸­ `$` æ˜¯æ—¢æ²¡æœ‰å‡ºç°åœ¨ `P` åˆæ²¡æœ‰å‡ºç°åœ¨ `T` ä¸­çš„å­—ç¬¦ã€‚ç„¶åæˆ‘ä»¬å¯¹ `$` è¿è¡Œè¿™ä¸ªç®—æ³•æ¥æ´»çš„ Z æ•°ç»„ã€‚æˆ‘ä»¬ç°åœ¨è¦åšçš„æ‰€æœ‰äº‹æƒ…å°±æ˜¯æ‰«æ Z æ•°ç»„æ¥æŸ¥æ‰¾å’Œ `n` ï¼ˆæ¨¡å¼çš„é•¿åº¦ï¼‰ç›¸ç­‰çš„å…ƒç´ ã€‚å½“æˆ‘ä»¬æ‰¾åˆ°è¿™æ ·çš„å€¼çš„æ—¶å€™å°±å¯ä»¥æŠ¥å‘Šè¯´æœ‰åŒ¹é…ã€‚

```swift
extension String {

    func indexesOf(pattern: String) -> [Int]? {
        let patternLength: Int = pattern.characters.count
        /* Let's calculate the Z-Algorithm on the concatenation of pattern and text */
        let zeta = ZetaAlgorithm(ptrn: pattern + "ğŸ’²" + self)

        guard zeta != nil else {
            return nil
        }

        var indexes: [Int] = [Int]()

        /* Scan the zeta array to find matched patterns */
        for i in 0 ..< zeta!.count {
            if zeta![i] == patternLength {
                indexes.append(i - patternLength - 1)
            }
        }

        guard !indexes.isEmpty else {
            return nil
        }

        return indexes
    }
}
```

ä¸¾ä¸ªä¾‹å­ã€‚å‡è®¾ `P = â€œCATAâ€œ`ï¼Œ `T = "GAGAACATACATGACCAT"`æ˜¯æ¨¡å¼å’Œæ–‡æœ¬ã€‚å°†è¿™ä¸¤ä¸ªåˆå¹¶åˆ°ä¸€èµ·ç»„æˆä¸€ä¸ª `$` å¾—åˆ° `S = "CATA$GAGAACATACATGACCAT"`ã€‚å¯¹ `S` åº”ç”¨ Z ç®—æ³•ä¹‹åå¾—åˆ°ï¼š

                1         2
      01234567890123456789012
      CATA$GAGAACATACATGACCAT
    Z 00000000004000300001300
                ^

ç„¶åæ‰«æ Z æ•°ç»„ï¼Œåœ¨ä½ç½® 10 çš„ä½ç½®å‘ç° `Z[10] = 4 = n`ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠ¥å‘Šè¯´åœ¨æ–‡æœ¬ä½ç½® `10 - n - 1 = 5` çš„åœ°æ–¹æœ‰ä¸€ä¸ªåŒ¹é…ã€‚

å°±åƒä¹‹å‰è¯´çš„ï¼Œè¿™ä¸ªç®—æ³•çš„å¤æ‚åº¦æ˜¯çº¿æ€§çš„ã€‚å®šä¹‰ `n` å’Œ `m` ä¸ºæ¨¡å¼å’Œæ–‡æœ¬çš„é•¿åº¦ï¼Œæœ€åæˆ‘ä»¬å¾—åˆ°çš„å¤æ‚åº¦æ˜¯ `O(n + m + 1) = O(n + m)`ã€‚


å‚è€ƒï¼š ä»£ç æ˜¯åŸºäºè¿™æœ¬ä¹¦çš„ ["Algorithm on String, Trees and Sequences: Computer Science and Computational Biology"](https://books.google.it/books/about/Algorithms_on_Strings_Trees_and_Sequence.html?id=Ofw5w1yuD8kC&redir_esc=y) by Dan Gusfield, Cambridge University Press, 1997. 

*ä½œè€…ï¼šMatteo Dunnhofer ç¿»è¯‘ï¼šDaisy*



<!DOCTYPE html>
<head>
  <title>Myers Difference Algorithm</title>
  <link rel="stylesheet" type="text/css" href="../github-light.css">
</head>
<body>
  <div id="container"><h1>Myers Difference Algorithm</h1>
<p>Myers Difference Algorithm(MDA) is an algorithm that finds a longest common subsequence(LCS) or shortest edit scripts(SES) of two sequences. The common subsequence of two sequences is the sequence of elements that appear in the same order in both sequences. For example, let's assume you have two arrays:</p>
<pre><code>let firstArray = [1, 2, 3]
let secondArray = [2, 3, 4]
</code></pre>
<p>The common subsequences of these two arrays are <code>[2]</code>, and <code>[2, 3]</code>. The longest common sequence in this case is <code>[2, 3]</code>. MDA can accomplish this in O(ND) time, where N is the sum of the lengths of the two sequences.</p>
<h2>Finding the length of the Longest Common Subsequence with Myers Algorithm on Edit Graph</h2>
<h3>Edit Graph</h3>
<p>MDA uses an <strong>Edit Graph</strong> to solve the LCS/SES problem. Below is a illustration depicting an edit graph:</p>
<p><a target="_blank" rel="noopener noreferrer" href="Images/EditGraph.png"><img src="Images/EditGraph.png" height="400" style="max-width:100%;"></a></p>
<p>The x-axis at the top of the graph represents one of the sequences, <code>X</code>. The y-axis at the left side of the graph represents the other sequence, <code>Y</code>. Hence, the two sequences in question is the following:</p>
<pre><code>X = [A, B, C, A, B, B, A]
Y = [C, B, A, B, A, C]
</code></pre>
<p>MDA generates the edit graph through the following steps:</p>
<ol>
<li>Line the element of sequence <code>X</code> on the x axis. And do for <code>Y</code> on the y axis.</li>
<li>Make grid and vertex at each point in the grid (x, y), <code>x in [0, N] and y in [0, M]</code>. <code>N</code> is the length of sequence <code>X</code>, <code>M</code> is of <code>Y</code></li>
<li>Line for <code>x - y = k</code>, this line called k-line. Black dot line is this and pink number is the value of k.</li>
<li>Check the points <code>(i, j)</code>, where <code>X[i] = Y[j]</code>, called match point, light green one.</li>
<li>Connect vertex <code>(i - 1, j - 1)</code> and vertex <code>(i, j)</code>, where <code>(i, j)</code> is match point, then diagonal edge appears.</li>
</ol>
<p>Each elements on the figure shows that,</p>
<ul>
<li><code>Red number and dotted lines</code>: The red number is the value of k and dotted lines are k-line.</li>
<li><code>Green dots: The match points</code>, which is the point <code>(i, j)</code> where <code>X[i] == Y[j]</code></li>
<li><code>Blue line</code>: The shortest path from source to sink, which is the path we are going to find finally.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> Here, the sequences' start index is 1 not 0, so <code>X[1] = A</code>, <code>Y[1] = C</code></p>
</blockquote>
<p>We discuss about which path is the shortest from <code>source</code> to <code>sink</code>. Can move on the edges on the graph. I mean we can move on  the grid, horizontal and vertical edges, and the diagonal edges.</p>
<p>The movements are compatible with the <code>Edit Scripts</code>, insert or delete. The word <code>Edit Scripts</code> appeared here, as referred at Introduction, SES is Shortest Edit Scripts.</p>
<p>Let's get back on track. On this edit graph, the horizontal movement to vertex <code>(i, j)</code> is compatible with the script  <code>delete at index i from X</code>, the vertical movement to vertex <code>(i, j)</code> is compatible with the script <code>insert the element of Y at index j to immediately after the element of X at index i</code>. How about for the diagonal movement?. This movement to vertex <code>(i, j)</code> means <code>X[i] = Y[j]</code>, so no script needs.</p>
<ul>
<li>horizontal movement -&gt; delete</li>
<li>vertical movement -&gt; insert</li>
<li>diagonal movement -&gt; no script because both are same.</li>
</ul>
<p>Next, add cost 1 for non-diagonal movement, because they can be compatible with script. And 0 for diagonal movement, same means no script.</p>
<p>The total cost for the minimum path, exploring from <code>source</code> to <code>sink</code>, is the same as the length of the Longest Common Subsequence or Shortest Edit Script.</p>
<p>So, LCS/SES problem can be solved by finding the shortest path from <code>source</code> to <code>sink</code>.</p>
<h3>Myers Algorithm</h3>
<p>As mentioned above, the problem of finding a shortest edit script can be reduced to finding a path from <code>source (0, 0)</code> to <code>sink (N, M)</code> with the fewest number of horizontal and vertical edges. Let <code>D-path</code> be a path starting at <code>source</code> that has exactly <code>D</code> non-diagonal edges, or must move non-diagonally D-times.</p>
<p>For example, A 0-path consists solely of diagonal edges. This means both sequences are completely same.</p>
<p>By a simple induction, D-path must consist of a (D-1)-path followed by a non-diagonal edge and then diagonal edges, which called <code>snake</code>. The minimum value of D is 0, both sequences being same. To the contrary, the maximum value of D is N + M because delete all elements from X and insert all elements from Y to X is the worst case edit scripts. For getting D, or the length of SES, running loop from 0 to N + M is enough.</p>
<div class="highlight highlight-source-swift"><pre><span class="pl-k">for</span> D <span class="pl-k">in</span> <span class="pl-c1">0</span><span class="pl-k">...</span><span class="pl-smi">N</span> <span class="pl-k">+</span> M</pre></div>
<p>Next, thinking about, where is the furthest reaching point for D-path on k-line. Like below, moving horizontally from k-line reaches (k+1)-line, moving vertically from k-line reaches (k-1)-line. Red chalky line shows that.</p>
<p><a target="_blank" rel="noopener noreferrer" href="Images/EditGraph_k_move.png"><img src="Images/EditGraph_k_move.png" height="400" style="max-width:100%;"></a></p>
<p>So, threre are several end points of D-path, or D-path can end on several k-line. We need the information to get the next path ((D+1)-path) as mentioned above. In fact, D-path must end on<br>
k-line, where k in { -D, -D + 2, ....., D - 2, D }. This is so simple, starting point, <code>source</code> is <code>(0, 0)</code> on (k=0)-line. D is the number of non-diagonal edges and non-diagonal movement changes current k-line to (kpm1)-line. Because 0 is even number, if D is even number D-path will end on (even_k)-line, if D is odd number D-path will end on (odd_k)-line.</p>
<p>Searching loop outline will be below.</p>
<div class="highlight highlight-source-swift"><pre><span class="pl-k">for</span> D <span class="pl-k">in</span> <span class="pl-c1">0</span><span class="pl-k">...</span><span class="pl-smi">N</span> <span class="pl-k">+</span> M {
    <span class="pl-k">for</span> k <span class="pl-k">in</span> <span class="pl-c1">stride</span>(<span class="pl-c1">from</span>: <span class="pl-k">-</span>D, <span class="pl-c1">through</span>: D, <span class="pl-c1">by</span>: <span class="pl-c1">2</span>) {
        <span class="pl-c"><span class="pl-c">//</span>Find the end point of the furthest reaching D-path in k-line.</span>
<span class="pl-c"></span>        <span class="pl-k">if</span> furthestReachingX <span class="pl-k">==</span> N <span class="pl-k">&amp;&amp;</span> furthestReachingY <span class="pl-k">==</span> M {
            <span class="pl-c"><span class="pl-c">//</span> The D-path is the shortest path</span>
<span class="pl-c"></span>            <span class="pl-c"><span class="pl-c">//</span> D is the length of Shortest Edit Script</span>
<span class="pl-c"></span>            <span class="pl-k">return</span>
        }
    }
}</pre></div>
<p>The D-path on k-line can be decomposed into</p>
<ul>
<li>a furthest reaching (D-1)-path on (k-1)-line, followed by a horizontal edge, followed by <code>snake</code>.</li>
<li>a furthest reaching (D-1)-path on (k+1)-line, followed by a vertical edge, followed by <code>snake</code>.<br>
as discussed above.</li>
</ul>
<p>The Myers Algorithm key point are these.</p>
<ul>
<li>D-path must end on k-line, where k in { -D, -D + 2, ....., D - 2, D }</li>
<li>The D-path on k-line can be decomposed into two patterns</li>
</ul>
<p>thanks for these, the number of calculation become less.</p>
<div class="highlight highlight-source-swift"><pre><span class="pl-k">public</span> <span class="pl-k">struct</span> <span class="pl-en">MyersDifferenceAlgorithm</span>&lt;<span class="pl-c1">E</span>: <span class="pl-e"><span class="pl-c1">Equatable</span></span>&gt; {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">func</span> <span class="pl-en">calculateShortestEditDistance</span>(<span class="pl-en">from</span> <span class="pl-smi">fromArray</span>: <span class="pl-c1">Array</span>&lt;E&gt;, <span class="pl-en">to</span> <span class="pl-smi">toArray</span>: <span class="pl-c1">Array</span>&lt;E&gt;) <span class="pl-k">-&gt;</span> <span class="pl-c1">Int</span> {
        <span class="pl-k">let</span> fromCount <span class="pl-k">=</span> fromArray.<span class="pl-c1">count</span>
        <span class="pl-k">let</span> toCount <span class="pl-k">=</span> toArray.<span class="pl-c1">count</span>
        <span class="pl-k">let</span> totalCount <span class="pl-k">=</span> toCount <span class="pl-k">+</span> fromCount
        <span class="pl-k">var</span> furthestReaching <span class="pl-k">=</span> <span class="pl-c1">Array</span>(<span class="pl-c1">repeating</span>: <span class="pl-c1">0</span>, <span class="pl-c1">count</span>: <span class="pl-c1">2</span> <span class="pl-k">*</span> totalCount <span class="pl-k">+</span> <span class="pl-c1">1</span>)

        <span class="pl-k">let</span> isReachedAtSink<span class="pl-k">:</span> (<span class="pl-c1">Int</span>, <span class="pl-c1">Int</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Bool</span> <span class="pl-k">=</span> { x, y <span class="pl-k">in</span>
            <span class="pl-k">return</span> x <span class="pl-k">==</span> fromCount <span class="pl-k">&amp;&amp;</span> y <span class="pl-k">==</span> toCount
        }

        <span class="pl-k">let</span> snake<span class="pl-k">:</span> (<span class="pl-c1">Int</span>, <span class="pl-c1">Int</span>, <span class="pl-c1">Int</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">Int</span> <span class="pl-k">=</span> { x, D, k <span class="pl-k">in</span>
            <span class="pl-k">var</span> _x <span class="pl-k">=</span> x
            <span class="pl-k">while</span> _x <span class="pl-k">&lt;</span> fromCount <span class="pl-k">&amp;&amp;</span> _x <span class="pl-k">-</span> k <span class="pl-k">&lt;</span> toCount <span class="pl-k">&amp;&amp;</span> fromArray[_x] <span class="pl-k">==</span> toArray[_x <span class="pl-k">-</span> k] {
                _x <span class="pl-k">+=</span> <span class="pl-c1">1</span>
            }
            <span class="pl-k">return</span> _x
        }

        <span class="pl-k">for</span> D <span class="pl-k">in</span> <span class="pl-c1">0</span><span class="pl-k">...</span><span class="pl-smi">totalCount</span> {
            <span class="pl-k">for</span> k <span class="pl-k">in</span> <span class="pl-c1">stride</span>(<span class="pl-c1">from</span>: <span class="pl-k">-</span>D, <span class="pl-c1">through</span>: D, <span class="pl-c1">by</span>: <span class="pl-c1">2</span>) {
                <span class="pl-k">let</span> index <span class="pl-k">=</span> k <span class="pl-k">+</span> totalCount
            
                <span class="pl-c"><span class="pl-c">//</span> (x, D, k) =&gt; the x position on the k_line where the number of scripts is D</span>
<span class="pl-c"></span>                <span class="pl-c"><span class="pl-c">//</span> scripts means insertion or deletion</span>
<span class="pl-c"></span>                <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">0</span>
                <span class="pl-k">if</span> D <span class="pl-k">==</span> <span class="pl-c1">0</span> { }
                    <span class="pl-c"><span class="pl-c">//</span> k == -D, D will be the boundary k_line</span>
<span class="pl-c"></span>                    <span class="pl-c"><span class="pl-c">//</span> when k == -D, moving right on the Edit Graph(is delete script) from k - 1_line where D - 1 is unavailable.</span>
<span class="pl-c"></span>                    <span class="pl-c"><span class="pl-c">//</span> when k == D, moving bottom on the Edit Graph(is insert script) from k + 1_line where D - 1 is unavailable.</span>
<span class="pl-c"></span>                    <span class="pl-c"><span class="pl-c">//</span> furthestReaching x position has higher calculating priority. (x, D - 1, k - 1), (x, D - 1, k + 1)</span>
<span class="pl-c"></span>                <span class="pl-k">else</span> <span class="pl-k">if</span> k <span class="pl-k">==</span> <span class="pl-k">-</span>D <span class="pl-k">||</span> k <span class="pl-k">!=</span> D <span class="pl-k">&amp;&amp;</span> furthestReaching[index <span class="pl-k">-</span> <span class="pl-c1">1</span>] <span class="pl-k">&lt;</span> furthestReaching[index <span class="pl-k">+</span> <span class="pl-c1">1</span>] {
                    <span class="pl-c"><span class="pl-c">//</span> Getting initial x position</span>
<span class="pl-c"></span>                    <span class="pl-c"><span class="pl-c">//</span> ,using the furthestReaching X position on the k + 1_line where D - 1</span>
<span class="pl-c"></span>                    <span class="pl-c"><span class="pl-c">//</span> ,meaning get (x, D, k) by (x, D - 1, k + 1) + moving bottom + snake</span>
<span class="pl-c"></span>                    <span class="pl-c"><span class="pl-c">//</span> this moving bottom on the edit graph is compatible with insert script</span>
<span class="pl-c"></span>                    x <span class="pl-k">=</span> furthestReaching[index <span class="pl-k">+</span> <span class="pl-c1">1</span>]
                } <span class="pl-k">else</span> {
                    <span class="pl-c"><span class="pl-c">//</span> Getting initial x position</span>
<span class="pl-c"></span>                    <span class="pl-c"><span class="pl-c">//</span> ,using the futrhest X position on the k - 1_line where D - 1</span>
<span class="pl-c"></span>                    <span class="pl-c"><span class="pl-c">//</span> ,meaning get (x, D, k) by (x, D - 1, k - 1) + moving right + snake</span>
<span class="pl-c"></span>                    <span class="pl-c"><span class="pl-c">//</span> this moving right on the edit graph is compatible with delete script</span>
<span class="pl-c"></span>                    x <span class="pl-k">=</span> furthestReaching[index <span class="pl-k">-</span> <span class="pl-c1">1</span>] <span class="pl-k">+</span> <span class="pl-c1">1</span>
                }
                
                <span class="pl-c"><span class="pl-c">//</span> snake</span>
<span class="pl-c"></span>                <span class="pl-c"><span class="pl-c">//</span> diagonal moving can be performed with 0 cost.</span>
<span class="pl-c"></span>                <span class="pl-c"><span class="pl-c">//</span> `same` script is needed ?</span>
<span class="pl-c"></span>                <span class="pl-k">let</span> _x <span class="pl-k">=</span> <span class="pl-c1">snake</span>(x, D, k)
                
                <span class="pl-k">if</span> <span class="pl-c1">isReachedAtSink</span>(_x, _x <span class="pl-k">-</span> k) { <span class="pl-k">return</span> D }
                furthestReaching[index] <span class="pl-k">=</span> _x
            }
        }

        <span class="pl-c1">fatalError</span>(<span class="pl-s"><span class="pl-pds">"</span>Never comes here<span class="pl-pds">"</span></span>)
    }
}</pre></div></div>
</body>
</html>

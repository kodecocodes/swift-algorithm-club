<!DOCTYPE html>
<head>
  <title>Minimum Spanning Tree (Unweighted)</title>
  <link rel="stylesheet" type="text/css" href="../github-light.css">
</head>
<body>
  <div id="container"><h1>Minimum Spanning Tree (Unweighted Graph)</h1>
<p>A minimum spanning tree describes a path that contains the smallest number of edges that are needed to visit every node in the graph.</p>
<p>Take a look at the following graph:</p>
<p><a target="_blank" rel="noopener noreferrer" href="Images/Graph.png"><img src="Images/Graph.png" alt="Graph" style="max-width:100%;"></a></p>
<p>If we start from node <code>a</code> and want to visit every other node, then what is the most efficient path to do that? We can calculate this with the minimum spanning tree algorithm.</p>
<p>Here is the minimum spanning tree for the graph. It is represented by the bold edges:</p>
<p><a target="_blank" rel="noopener noreferrer" href="Images/MinimumSpanningTree.png"><img src="Images/MinimumSpanningTree.png" alt="Minimum spanning tree" style="max-width:100%;"></a></p>
<p>Drawn as a more conventional tree it looks like this:</p>
<p><a target="_blank" rel="noopener noreferrer" href="Images/Tree.png"><img src="Images/Tree.png" alt="An actual tree" style="max-width:100%;"></a></p>
<p>To calculate the minimum spanning tree on an unweighted graph, we can use the <a href="../Breadth-First%20Search/">breadth-first search</a> algorithm. Breadth-first search starts at a source node and traverses the graph by exploring the immediate neighbor nodes first, before moving to the next level neighbors. If we tweak this algorithm by selectively removing edges, then it can convert the graph into the minimum spanning tree.</p>
<p>Let's step through the example. We start with the source node <code>a</code>, add it to a queue and mark it as visited.</p>
<div class="highlight highlight-source-swift"><pre>queue.<span class="pl-c1">enqueue</span>(a)
a.<span class="pl-smi">visited</span> <span class="pl-k">=</span> <span class="pl-c1">true</span></pre></div>
<p>The queue is now <code>[ a ]</code>. As is usual with breadth-first search, we dequeue the node at the front of the queue, <code>a</code>, and enqueue its immediate neighbor nodes <code>b</code> and <code>h</code>. We mark them as visited too.</p>
<div class="highlight highlight-source-swift"><pre>queue.<span class="pl-c1">dequeue</span>()   <span class="pl-c"><span class="pl-c">//</span> a</span>
<span class="pl-c"></span>queue.<span class="pl-c1">enqueue</span>(b)
b.<span class="pl-smi">visited</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>
queue.<span class="pl-c1">enqueue</span>(h)
h.<span class="pl-smi">visited</span> <span class="pl-k">=</span> <span class="pl-c1">true</span></pre></div>
<p>The queue is now <code>[ b, h ]</code>. Dequeue <code>b</code> and enqueue the neighbor node <code>c</code>. Mark it as visited. Remove the edge from <code>b</code> to <code>h</code> because <code>h</code> has already been visited.</p>
<div class="highlight highlight-source-swift"><pre>queue.<span class="pl-c1">dequeue</span>()   <span class="pl-c"><span class="pl-c">//</span> b</span>
<span class="pl-c"></span>queue.<span class="pl-c1">enqueue</span>(c)
c.<span class="pl-smi">visited</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>
b.<span class="pl-c1">removeEdgeTo</span>(h)</pre></div>
<p>The queue is now <code>[ h, c ]</code>. Dequeue <code>h</code> and enqueue the neighbor nodes <code>g</code> and <code>i</code>, and mark them as visited.</p>
<div class="highlight highlight-source-swift"><pre>queue.<span class="pl-c1">dequeue</span>()   <span class="pl-c"><span class="pl-c">//</span> h</span>
<span class="pl-c"></span>queue.<span class="pl-c1">enqueue</span>(g)
g.<span class="pl-smi">visited</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>
queue.<span class="pl-c1">enqueue</span>(i)
i.<span class="pl-smi">visited</span> <span class="pl-k">=</span> <span class="pl-c1">true</span></pre></div>
<p>The queue is now <code>[ c, g, i ]</code>. Dequeue <code>c</code> and enqueue the neighbor nodes <code>d</code> and <code>f</code>, and mark them as visited. Remove the edge between <code>c</code> and <code>i</code> because <code>i</code> has already been visited.</p>
<div class="highlight highlight-source-swift"><pre>queue.<span class="pl-c1">dequeue</span>()   <span class="pl-c"><span class="pl-c">//</span> c</span>
<span class="pl-c"></span>queue.<span class="pl-c1">enqueue</span>(d)
d.<span class="pl-smi">visited</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>
queue.<span class="pl-c1">enqueue</span>(f)
f.<span class="pl-smi">visited</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>
c.<span class="pl-c1">removeEdgeTo</span>(i)</pre></div>
<p>The queue is now <code>[ g, i, d, f ]</code>. Dequeue <code>g</code>. All of its neighbors have been discovered already, so there is nothing to enqueue. Remove the edges from <code>g</code> to <code>f</code>, as well as <code>g</code> to <code>i</code>, because <code>f</code> and <code>i</code> have already been discovered.</p>
<div class="highlight highlight-source-swift"><pre>queue.<span class="pl-c1">dequeue</span>()   <span class="pl-c"><span class="pl-c">//</span> g</span>
<span class="pl-c"></span>g.<span class="pl-c1">removeEdgeTo</span>(f)
g.<span class="pl-c1">removeEdgeTo</span>(i)</pre></div>
<p>The queue is now <code>[ i, d, f ]</code>. Dequeue <code>i</code>. Nothing else to do for this node.</p>
<div class="highlight highlight-source-swift"><pre>queue.<span class="pl-c1">dequeue</span>()   <span class="pl-c"><span class="pl-c">//</span> i</span></pre></div>
<p>The queue is now <code>[ d, f ]</code>. Dequeue <code>d</code> and enqueue the neighbor node <code>e</code>. Mark it as visited. Remove the edge from <code>d</code> to <code>f</code> because <code>f</code> has already been visited.</p>
<div class="highlight highlight-source-swift"><pre>queue.<span class="pl-c1">dequeue</span>()   <span class="pl-c"><span class="pl-c">//</span> d</span>
<span class="pl-c"></span>queue.<span class="pl-c1">enqueue</span>(e)
e.<span class="pl-smi">visited</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>
d.<span class="pl-c1">removeEdgeTo</span>(f)</pre></div>
<p>The queue is now <code>[ f, e ]</code>. Dequeue <code>f</code>. Remove the edge between <code>f</code> and <code>e</code> because <code>e</code> has already been visited.</p>
<div class="highlight highlight-source-swift"><pre>queue.<span class="pl-c1">dequeue</span>()   <span class="pl-c"><span class="pl-c">//</span> f</span>
<span class="pl-c"></span>f.<span class="pl-c1">removeEdgeTo</span>(e)</pre></div>
<p>The queue is now <code>[ e ]</code>. Dequeue <code>e</code>.</p>
<div class="highlight highlight-source-swift"><pre>queue.<span class="pl-c1">dequeue</span>()   <span class="pl-c"><span class="pl-c">//</span> e</span></pre></div>
<p>The queue is empty, which means the minimum spanning tree has been computed.</p>
<p>Here's the code:</p>
<div class="highlight highlight-source-swift"><pre><span class="pl-k">func</span> <span class="pl-en">breadthFirstSearchMinimumSpanningTree</span>(<span class="pl-smi"><span class="pl-en">graph</span></span>: Graph, <span class="pl-smi"><span class="pl-en">source</span></span>: Node) <span class="pl-k">-&gt;</span> Graph {
  <span class="pl-k">let</span> minimumSpanningTree <span class="pl-k">=</span> graph.<span class="pl-c1">duplicate</span>()

  <span class="pl-k">var</span> queue <span class="pl-k">=</span> Queue<span class="pl-k">&lt;</span>Node<span class="pl-k">&gt;</span>()
  <span class="pl-k">let</span> sourceInMinimumSpanningTree <span class="pl-k">=</span> minimumSpanningTree.<span class="pl-c1">findNodeWithLabel</span>(source.<span class="pl-smi">label</span>)
  queue.<span class="pl-c1">enqueue</span>(sourceInMinimumSpanningTree)
  sourceInMinimumSpanningTree.<span class="pl-smi">visited</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>

  <span class="pl-k">while</span> <span class="pl-k">let</span> current <span class="pl-k">=</span> queue.<span class="pl-c1">dequeue</span>() {
    <span class="pl-k">for</span> edge <span class="pl-k">in</span> current.<span class="pl-smi">neighbors</span> {
      <span class="pl-k">let</span> neighborNode <span class="pl-k">=</span> edge.<span class="pl-smi">neighbor</span>
      <span class="pl-k">if</span> <span class="pl-k">!</span>neighborNode.<span class="pl-smi">visited</span> {
        neighborNode.<span class="pl-smi">visited</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>
        queue.<span class="pl-c1">enqueue</span>(neighborNode)
      } <span class="pl-k">else</span> {
        current.<span class="pl-c1">remove</span>(edge)
      }
    }
  }

  <span class="pl-k">return</span> minimumSpanningTree
}</pre></div>
<p>This function returns a new <code>Graph</code> object that describes just the minimum spanning tree. In the figure, that would be the graph containing just the bold edges.</p>
<p>Put this code in a playground and test it like so:</p>
<div class="highlight highlight-source-swift"><pre><span class="pl-k">let</span> graph <span class="pl-k">=</span> <span class="pl-c1">Graph</span>()

<span class="pl-k">let</span> nodeA <span class="pl-k">=</span> graph.<span class="pl-c1">addNode</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>)
<span class="pl-k">let</span> nodeB <span class="pl-k">=</span> graph.<span class="pl-c1">addNode</span>(<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)
<span class="pl-k">let</span> nodeC <span class="pl-k">=</span> graph.<span class="pl-c1">addNode</span>(<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>)
<span class="pl-k">let</span> nodeD <span class="pl-k">=</span> graph.<span class="pl-c1">addNode</span>(<span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>)
<span class="pl-k">let</span> nodeE <span class="pl-k">=</span> graph.<span class="pl-c1">addNode</span>(<span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-pds">"</span></span>)
<span class="pl-k">let</span> nodeF <span class="pl-k">=</span> graph.<span class="pl-c1">addNode</span>(<span class="pl-s"><span class="pl-pds">"</span>f<span class="pl-pds">"</span></span>)
<span class="pl-k">let</span> nodeG <span class="pl-k">=</span> graph.<span class="pl-c1">addNode</span>(<span class="pl-s"><span class="pl-pds">"</span>g<span class="pl-pds">"</span></span>)
<span class="pl-k">let</span> nodeH <span class="pl-k">=</span> graph.<span class="pl-c1">addNode</span>(<span class="pl-s"><span class="pl-pds">"</span>h<span class="pl-pds">"</span></span>)
<span class="pl-k">let</span> nodeI <span class="pl-k">=</span> graph.<span class="pl-c1">addNode</span>(<span class="pl-s"><span class="pl-pds">"</span>i<span class="pl-pds">"</span></span>)

graph.<span class="pl-c1">addEdge</span>(nodeA, <span class="pl-c1">neighbor</span>: nodeB)
graph.<span class="pl-c1">addEdge</span>(nodeA, <span class="pl-c1">neighbor</span>: nodeH)
graph.<span class="pl-c1">addEdge</span>(nodeB, <span class="pl-c1">neighbor</span>: nodeA)
graph.<span class="pl-c1">addEdge</span>(nodeB, <span class="pl-c1">neighbor</span>: nodeC)
graph.<span class="pl-c1">addEdge</span>(nodeB, <span class="pl-c1">neighbor</span>: nodeH)
graph.<span class="pl-c1">addEdge</span>(nodeC, <span class="pl-c1">neighbor</span>: nodeB)
graph.<span class="pl-c1">addEdge</span>(nodeC, <span class="pl-c1">neighbor</span>: nodeD)
graph.<span class="pl-c1">addEdge</span>(nodeC, <span class="pl-c1">neighbor</span>: nodeF)
graph.<span class="pl-c1">addEdge</span>(nodeC, <span class="pl-c1">neighbor</span>: nodeI)
graph.<span class="pl-c1">addEdge</span>(nodeD, <span class="pl-c1">neighbor</span>: nodeC)
graph.<span class="pl-c1">addEdge</span>(nodeD, <span class="pl-c1">neighbor</span>: nodeE)
graph.<span class="pl-c1">addEdge</span>(nodeD, <span class="pl-c1">neighbor</span>: nodeF)
graph.<span class="pl-c1">addEdge</span>(nodeE, <span class="pl-c1">neighbor</span>: nodeD)
graph.<span class="pl-c1">addEdge</span>(nodeE, <span class="pl-c1">neighbor</span>: nodeF)
graph.<span class="pl-c1">addEdge</span>(nodeF, <span class="pl-c1">neighbor</span>: nodeC)
graph.<span class="pl-c1">addEdge</span>(nodeF, <span class="pl-c1">neighbor</span>: nodeD)
graph.<span class="pl-c1">addEdge</span>(nodeF, <span class="pl-c1">neighbor</span>: nodeE)
graph.<span class="pl-c1">addEdge</span>(nodeF, <span class="pl-c1">neighbor</span>: nodeG)
graph.<span class="pl-c1">addEdge</span>(nodeG, <span class="pl-c1">neighbor</span>: nodeF)
graph.<span class="pl-c1">addEdge</span>(nodeG, <span class="pl-c1">neighbor</span>: nodeH)
graph.<span class="pl-c1">addEdge</span>(nodeG, <span class="pl-c1">neighbor</span>: nodeI)
graph.<span class="pl-c1">addEdge</span>(nodeH, <span class="pl-c1">neighbor</span>: nodeA)
graph.<span class="pl-c1">addEdge</span>(nodeH, <span class="pl-c1">neighbor</span>: nodeB)
graph.<span class="pl-c1">addEdge</span>(nodeH, <span class="pl-c1">neighbor</span>: nodeG)
graph.<span class="pl-c1">addEdge</span>(nodeH, <span class="pl-c1">neighbor</span>: nodeI)
graph.<span class="pl-c1">addEdge</span>(nodeI, <span class="pl-c1">neighbor</span>: nodeC)
graph.<span class="pl-c1">addEdge</span>(nodeI, <span class="pl-c1">neighbor</span>: nodeG)
graph.<span class="pl-c1">addEdge</span>(nodeI, <span class="pl-c1">neighbor</span>: nodeH)

<span class="pl-k">let</span> minimumSpanningTree <span class="pl-k">=</span> <span class="pl-c1">breadthFirstSearchMinimumSpanningTree</span>(graph, <span class="pl-c1">source</span>: nodeA)

<span class="pl-c1">print</span>(minimumSpanningTree) <span class="pl-c"><span class="pl-c">//</span> [node: a edges: ["b", "h"]]</span>
<span class="pl-c"></span>                           <span class="pl-c"><span class="pl-c">//</span> [node: b edges: ["c"]]</span>
<span class="pl-c"></span>                           <span class="pl-c"><span class="pl-c">//</span> [node: c edges: ["d", "f"]]</span>
<span class="pl-c"></span>                           <span class="pl-c"><span class="pl-c">//</span> [node: d edges: ["e"]]</span>
<span class="pl-c"></span>                           <span class="pl-c"><span class="pl-c">//</span> [node: h edges: ["g", "i"]]</span></pre></div>
<blockquote>
<p><strong>Note:</strong> On an unweighed graph, any spanning tree is always a minimal spanning tree. This means you can also use a <a href="../Depth-First%20Search">depth-first search</a> to find the minimum spanning tree.</p>
</blockquote>
<p><em>Written by <a href="https://github.com/chris-pilcher">Chris Pilcher</a> and Matthijs Hollemans</em></p></div>
</body>
</html>
